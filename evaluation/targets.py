import os
import subprocess
from typing import Any, Dict

import httpx


def _agent_mode() -> str:
    return (os.environ.get("EDEN_AGENT_MODE") or "stub").strip().lower()


def _agent_http_url() -> str:
    return (os.environ.get("EDEN_AGENT_HTTP_URL") or "").strip()


def _agent_cmd() -> str:
    return (os.environ.get("EDEN_AGENT_CMD") or "").strip()


def _call_http(query: str) -> str:
    url = _agent_http_url()
    if not url:
        raise RuntimeError("EDEN_AGENT_HTTP_URL is required when EDEN_AGENT_MODE=http")

    with httpx.Client(timeout=60.0, follow_redirects=True) as client:
        resp = client.post(url, json={"query": query})
        resp.raise_for_status()
        data = resp.json()

    if isinstance(data, dict) and isinstance(data.get("response"), str):
        return data["response"]

    raise RuntimeError("HTTP agent response must be JSON: { 'response': '...' }")


def _call_cmd(query: str) -> str:
    cmd = _agent_cmd()
    if not cmd:
        raise RuntimeError("EDEN_AGENT_CMD is required when EDEN_AGENT_MODE=cmd")

    proc = subprocess.run(
        cmd,
        input=query,
        text=True,
        capture_output=True,
        shell=True,
        check=False,
    )

    if proc.returncode != 0:
        raise RuntimeError(f"Agent command failed (exit {proc.returncode}): {proc.stderr.strip()}")

    return proc.stdout


def _call_stub(query: str, *, kind: str) -> str:
    # Minimal predictable output for plumbing.
    if kind == "envgen":
        return "\n".join(
            [
                "# Generated by stub",
                "APPDATA_ROOT=/volume1/docker/appdata",
                "DATA_ROOT=/volume1/data",
                "TRANSCODE_ROOT=/volume1/docker/transcode",
                "PUID=1026",
                "PGID=100",
                "TZ=America/Chicago",
                "PLEX_CLAIM=",
                "ADVERTISE_IP=",
                "",
            ]
        )

    return "Use Plex, Sonarr, and Radarr only. Keep it LAN-only."


def _call_agent(query: str, *, kind: str) -> str:
    mode = _agent_mode()
    if mode == "http":
        return _call_http(query)
    if mode == "cmd":
        return _call_cmd(query)
    return _call_stub(query, kind=kind)


def chatbot_target(query: str) -> Dict[str, Any]:
    response = _call_agent(query, kind="chatbot")
    return {"response": response}


def envgen_target(query: str) -> Dict[str, Any]:
    env_text = _call_agent(query, kind="envgen")
    # Use the same output field name "response" for evaluator compatibility.
    return {"response": env_text}
