import os
import re
import secrets
from pathlib import Path
from zoneinfo import available_timezones
from flask import Flask, Response, abort, make_response, render_template, request
from werkzeug.exceptions import HTTPException
from werkzeug.exceptions import HTTPException

app = Flask(__name__)
app.config["MAX_CONTENT_LENGTH"] = 32 * 1024

# Used for signing cookies (if Flask ever needs it). Not persisted.
app.secret_key = os.environ.get("SETUP_UI_SECRET_KEY") or secrets.token_hex(32)

DEFAULTS = {
    "APPDATA_ROOT": "/volume1/docker/appdata",
    "DATA_ROOT": "/volume1/data",
    "TRANSCODE_ROOT": "/volume1/docker/transcode",
    "PUID": "1026",
    "PGID": "100",
    "TZ": "America/Chicago",
    "PLEX_CLAIM": "",
}


_SAFE_LINE_RE = re.compile(r"[\r\n]")


def _sanitize_env_value(value: str) -> str:
    # Prevent newline injection into the generated .env file.
    value = (value or "").strip()
    return _SAFE_LINE_RE.sub("", value)


def _sanitize_numeric(value: str) -> str:
    value = _sanitize_env_value(value)
    if not value.isdigit():
        abort(400, description="Must be numeric")
    return value


def _ensure_valid_timezone(value: str, tz_set: set[str]) -> str:
    value = _sanitize_env_value(value)
    if value not in tz_set:
        abort(400, description="Invalid timezone")
    return value


def _get_or_set_csrf() -> str:
    token = request.cookies.get("csrf")
    if not token:
        token = secrets.token_urlsafe(32)
    return token


def _render_index(
    *,
    error_message: str | None = None,
    status_code: int = 200,
    overrides: dict[str, str] | None = None,
    field_errors: dict[str, str] | None = None,
):
    repo_env_example = Path(os.environ.get("REPO_ENV_EXAMPLE", "/repo/.env.example"))
    file_defaults = parse_env_file(repo_env_example)

    merged = dict(DEFAULTS)
    merged.update({k: v for k, v in file_defaults.items() if v is not None})
    if overrides:
        merged.update({k: v for k, v in overrides.items() if v is not None})

    timezones = sorted(available_timezones())
    csrf = _get_or_set_csrf()
    resp = make_response(
        render_template(
            "index.html",
            defaults=merged,
            timezones=timezones,
            csrf=csrf,
            error_message=error_message,
            field_errors=field_errors or {},
        ),
        status_code,
    )
    resp.set_cookie(
        "csrf",
        csrf,
        httponly=True,
        samesite="Strict",
        secure=bool(request.is_secure),
    )
    return resp


@app.errorhandler(HTTPException)
def handle_http_exception(e: HTTPException):
    message = e.description if isinstance(e.description, str) and e.description else "Request failed"
    return _render_index(error_message=message, status_code=e.code or 500)


@app.after_request
def add_security_headers(response: Response):
    # Basic hardening (Microsoft-style web app hygiene):
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["Referrer-Policy"] = "no-referrer"
    response.headers["Cache-Control"] = "no-store"
    response.headers["Pragma"] = "no-cache"
    response.headers["Content-Security-Policy"] = (
        "default-src 'self'; "
        "base-uri 'none'; "
        "frame-ancestors 'none'; "
        "form-action 'self'"
    )
    return response


def parse_env_file(path: Path) -> dict[str, str]:
    values: dict[str, str] = {}
    if not path.exists():
        return values

    for line in path.read_text(encoding="utf-8", errors="ignore").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        values[key.strip()] = value.strip()
    return values


def build_env_text(values: dict[str, str]) -> str:
    def get(key: str) -> str:
        return values.get(key, "").strip()

    # Keep the file minimal and predictable. No secrets are stored server-side.
    lines = [
        "# Generated by setup-ui (do not commit this file)",
        "",
        f"APPDATA_ROOT={get('APPDATA_ROOT')}",
        f"DATA_ROOT={get('DATA_ROOT')}",
        f"TRANSCODE_ROOT={get('TRANSCODE_ROOT')}",
        "",
        f"PUID={get('PUID')}",
        f"PGID={get('PGID')}",
        f"TZ={get('TZ')}",
        "",
        "# Optional. Only needed once to claim Plex.",
        f"PLEX_CLAIM={get('PLEX_CLAIM')}",
        "",
        "# Optional. Usually not needed with Plex host networking.",
        "ADVERTISE_IP=",
        "",
    ]
    return "\n".join(lines)


@app.get("/")
def index():
    return _render_index()


@app.post("/download")
def download():
    csrf_cookie = request.cookies.get("csrf")
    csrf_form = request.form.get("csrf", "")
    if not csrf_cookie or not csrf_form or csrf_cookie != csrf_form:
        abort(403, description="Your session expired. Refresh the page and try again.")

    tz_set = set(available_timezones())

    raw = {
        "APPDATA_ROOT": request.form.get("APPDATA_ROOT", ""),
        "DATA_ROOT": request.form.get("DATA_ROOT", ""),
        "TRANSCODE_ROOT": request.form.get("TRANSCODE_ROOT", ""),
        "PUID": request.form.get("PUID", ""),
        "PGID": request.form.get("PGID", ""),
        "TZ": request.form.get("TZ", ""),
        "PLEX_CLAIM": request.form.get("PLEX_CLAIM", ""),
    }

    overrides = {
        "APPDATA_ROOT": _sanitize_env_value(raw["APPDATA_ROOT"]),
        "DATA_ROOT": _sanitize_env_value(raw["DATA_ROOT"]),
        "TRANSCODE_ROOT": _sanitize_env_value(raw["TRANSCODE_ROOT"]),
        "PUID": _sanitize_env_value(raw["PUID"]),
        "PGID": _sanitize_env_value(raw["PGID"]),
        "TZ": _sanitize_env_value(raw["TZ"]),
    }

    values = {
        "APPDATA_ROOT": overrides["APPDATA_ROOT"],
        "DATA_ROOT": overrides["DATA_ROOT"],
        "TRANSCODE_ROOT": overrides["TRANSCODE_ROOT"],
        "PUID": overrides["PUID"],
        "PGID": overrides["PGID"],
        "TZ": overrides["TZ"],
        "PLEX_CLAIM": _sanitize_env_value(raw["PLEX_CLAIM"]),
    }

    field_errors: dict[str, str] = {}
    if not values["APPDATA_ROOT"]:
        field_errors["APPDATA_ROOT"] = "Required"
    if not values["DATA_ROOT"]:
        field_errors["DATA_ROOT"] = "Required"
    if not values["TRANSCODE_ROOT"]:
        field_errors["TRANSCODE_ROOT"] = "Required"

    if not values["PUID"] or not values["PUID"].isdigit():
        field_errors["PUID"] = "Must be numeric (example: 1026)"
    if not values["PGID"] or not values["PGID"].isdigit():
        field_errors["PGID"] = "Must be numeric (example: 100)"
    if values["TZ"] not in tz_set:
        field_errors["TZ"] = "Choose a valid timezone from the list"

    if field_errors:
        return _render_index(
            error_message="Fix the highlighted fields and try again.",
            status_code=400,
            overrides=overrides,
            field_errors=field_errors,
        )

    env_text = build_env_text(values)

    return Response(
        env_text,
        mimetype="text/plain; charset=utf-8",
        headers={
            "Content-Disposition": 'attachment; filename=".env"',
            "Cache-Control": "no-store",
        },
    )


if __name__ == "__main__":
    port = int(os.environ.get("PORT", "8080"))
    # LAN-only by default.
    app.run(host="0.0.0.0", port=port, debug=False)
