import os
import re
import secrets
from pathlib import Path
from zoneinfo import available_timezones
from flask import Flask, Response, abort, make_response, render_template, request
from werkzeug.exceptions import HTTPException

app = Flask(__name__)
app.config["MAX_CONTENT_LENGTH"] = 32 * 1024

# Used for signing cookies (if Flask ever needs it). Not persisted.
app.secret_key = os.environ.get("SETUP_UI_SECRET_KEY") or secrets.token_hex(32)

DEFAULTS = {
    "APPDATA_ROOT": "/volume1/docker/appdata",
    "DATA_ROOT": "/volume1/data",
    "TRANSCODE_ROOT": "/volume1/docker/transcode",
    "PUID": "1026",
    "PGID": "100",
    "TZ": "America/Chicago",
    "PLEX_CLAIM": "",
}


_SAFE_LINE_RE = re.compile(r"[\r\n]")


def _sanitize_env_value(value: str) -> str:
    # Prevent newline injection into the generated .env file.
    value = (value or "").strip()
    return _SAFE_LINE_RE.sub("", value)


def _sanitize_numeric(value: str) -> str:
    value = _sanitize_env_value(value)
    if not value.isdigit():
        abort(400, description="PUID/PGID must be numeric")
    return value


def _ensure_valid_timezone(value: str, tz_set: set[str]) -> str:
    value = _sanitize_env_value(value)
    if value not in tz_set:
        abort(400, description="Invalid TZ")
    return value


def _get_or_set_csrf() -> str:
    token = request.cookies.get("csrf")
    if not token:
        token = secrets.token_urlsafe(32)
    return token


def _render_index(*, error_message: str | None = None, status_code: int = 200, overrides: dict[str, str] | None = None):
    # If the repo is mounted, use .env.example to prefill defaults.
    repo_env_example = Path(os.environ.get("REPO_ENV_EXAMPLE", "/repo/.env.example"))
    file_defaults = parse_env_file(repo_env_example)

    merged = dict(DEFAULTS)
    merged.update({k: v for k, v in file_defaults.items() if v is not None})
    if overrides:
        merged.update({k: v for k, v in overrides.items() if v is not None})

    timezones = sorted(available_timezones())
    csrf = _get_or_set_csrf()
    resp = make_response(
        render_template(
            "index.html",
            defaults=merged,
            timezones=timezones,
            csrf=csrf,
            error_message=error_message,
        ),
        status_code,
    )
    # Secure cookies only when served over HTTPS.
    resp.set_cookie(
        "csrf",
        csrf,
        httponly=True,
        samesite="Strict",
        secure=bool(request.is_secure),
    )
    return resp


@app.errorhandler(HTTPException)
def handle_http_exception(e: HTTPException):
    message = e.description if isinstance(e.description, str) and e.description else "Request failed"
    return _render_index(error_message=message, status_code=e.code or 500)


@app.after_request
def add_security_headers(response: Response):
    # Basic hardening (Microsoft-style web app hygiene):
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["Referrer-Policy"] = "no-referrer"
    response.headers["Cache-Control"] = "no-store"
    response.headers["Pragma"] = "no-cache"
    response.headers["Content-Security-Policy"] = (
        "default-src 'self'; "
        "base-uri 'none'; "
        "frame-ancestors 'none'; "
        "form-action 'self'"
    )
    return response


def parse_env_file(path: Path) -> dict[str, str]:
    values: dict[str, str] = {}
    if not path.exists():
        return values

    for line in path.read_text(encoding="utf-8", errors="ignore").splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" not in line:
            continue
        key, value = line.split("=", 1)
        values[key.strip()] = value.strip()
    return values


def build_env_text(values: dict[str, str]) -> str:
    def get(key: str) -> str:
        return values.get(key, "").strip()

    # Keep the file minimal and predictable. No secrets are stored server-side.
    lines = [
        "# Generated by setup-ui (do not commit this file)",
        "",
        f"APPDATA_ROOT={get('APPDATA_ROOT')}",
        f"DATA_ROOT={get('DATA_ROOT')}",
        f"TRANSCODE_ROOT={get('TRANSCODE_ROOT')}",
        "",
        f"PUID={get('PUID')}",
        f"PGID={get('PGID')}",
        f"TZ={get('TZ')}",
        "",
        "# Optional. Only needed once to claim Plex.",
        f"PLEX_CLAIM={get('PLEX_CLAIM')}",
        "",
        "# Optional. Usually not needed with Plex host networking.",
        "ADVERTISE_IP=",
        "",
    ]
    return "\n".join(lines)


@app.get("/")
def index():
    return _render_index()


@app.post("/download")
def download():
    csrf_cookie = request.cookies.get("csrf")
    csrf_form = request.form.get("csrf", "")
    if not csrf_cookie or not csrf_form or csrf_cookie != csrf_form:
        abort(403, description="Your session expired. Refresh the page and try again.")

    tz_set = set(available_timezones())
    try:
        values = {
            "APPDATA_ROOT": _sanitize_env_value(request.form.get("APPDATA_ROOT", "")),
            "DATA_ROOT": _sanitize_env_value(request.form.get("DATA_ROOT", "")),
            "TRANSCODE_ROOT": _sanitize_env_value(request.form.get("TRANSCODE_ROOT", "")),
            "PUID": _sanitize_numeric(request.form.get("PUID", "")),
            "PGID": _sanitize_numeric(request.form.get("PGID", "")),
            "TZ": _ensure_valid_timezone(request.form.get("TZ", ""), tz_set),
            "PLEX_CLAIM": _sanitize_env_value(request.form.get("PLEX_CLAIM", "")),
        }
    except HTTPException as e:
        # Preserve what the user typed (but never reflect the claim token).
        overrides = {
            "APPDATA_ROOT": _sanitize_env_value(request.form.get("APPDATA_ROOT", "")),
            "DATA_ROOT": _sanitize_env_value(request.form.get("DATA_ROOT", "")),
            "TRANSCODE_ROOT": _sanitize_env_value(request.form.get("TRANSCODE_ROOT", "")),
            "PUID": _sanitize_env_value(request.form.get("PUID", "")),
            "PGID": _sanitize_env_value(request.form.get("PGID", "")),
            "TZ": _sanitize_env_value(request.form.get("TZ", "")),
        }
        return _render_index(error_message=e.description or "Invalid input", status_code=e.code or 400, overrides=overrides)

    env_text = build_env_text(values)

    return Response(
        env_text,
        mimetype="text/plain; charset=utf-8",
        headers={
            "Content-Disposition": 'attachment; filename=".env"',
            "Cache-Control": "no-store",
        },
    )


if __name__ == "__main__":
    port = int(os.environ.get("PORT", "8080"))
    # LAN-only by default.
    app.run(host="0.0.0.0", port=port, debug=False)
